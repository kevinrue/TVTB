---
title: Introduction to TVTB
author:
    -   name: Kévin Rue-Albrecht
        email: k.rue-albrecht@imperial.ac.uk
        affiliation: Department of Medicine, Imperial College London,
            Hammersmith Campus, Du Cane Road, London, W12 0NN, UK
date: "`r doc_date()`"
package: "`r pkg_ver('TVTB')`"
abstract:
    The VCF Tool Box (`r Biocpkg("TVTB")`) provides S4 classes and methods
    to filter,
    summarise and visualise genetic variation data stored in VCF files
    pre-processed by the Ensembl Variant Effect Predictor (VEP).
    In particular, the package extends the *FilterRules* class
    (`r Biocpkg("S4Vectors")` package) to define news classes of
    filter rules applicable to the various slots of `VCF` objects.
    A Shiny web-application, the Shiny Variant Explorer (*tSVE*),
    provides a convenient interface to demonstrate
    those functionalities integrated in a programming-free environment.
vignette: >
    %\VignetteIndexEntry{Introduction to TVTB}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output:
    BiocStyle::pdf_document2:
        toc_newpage: true
bibliography:
    TVTB.bib
---

```{r, optChunkDefault, include=FALSE}
library(knitr)
opts_chunk$set( # Set these first, to make them default
    message = FALSE,
    warning=FALSE,
    error=FALSE
)
optChunkDefault <- opts_chunk$get()
```

# Introduction {#Introduction}

The VCF Tool Box (`r Biocpkg("TVTB")`) offers S4 classes and methods
to filter, summarise and visualise genetic variation data
stored in VCF files pre-processed by the
[Ensembl Variant Effect Predictor](http://www.ensembl.org/info/docs/tools/vep)
(VEP) [@RN1].
An [RStudio/Shiny](http://shiny.rstudio.com) web-application,
the Shiny Variant Explorer (*tSVE*),
provides a convenient interface to demonstrate those
functionalities integrated in a programming-free environment.

Currently, major functionalities in the `r Biocpkg("TVTB")` package include:

**A class to store recurrent parameters of genetic analyses**

* List of reference homozygote, heterozygote, and alternate homozygote
    genotype encodings
* Suffix of the INFO fields where calculated data will be stored
* Key of the INFO field where Ensembl VEP predictions are stored
    in the VCF file
* List of genomic ranges to analyse and visualise
* Parameters for parallel calculations (using `r Biocpkg("BiocParallel")`)

**Genotype counts and allele frequencies**

* May be calculated from the data of an `ExpandedVCF` objects
    (*i.e.* bi-allelic records)
* Stored in INFO fields of the `ExpandedVCF` object
    + overall counts and frequencies (*i.e.* across all samples)
    + counts and frequencies within level(s) of phenotype(s)

**Classes of VCF filter rules**

* Filter rules applicable to the `fixed` slot of an `VCF` object
* Filter rules applicable to the `info` slot of an `VCF` object
* Filter rules applicable to the Ensembl VEP predictions stored in a
given INFO field of a `VCF` object
* A container for combinations of filter rules listed above
* Subset a `VCF` object using any combination of the above filter rules

**Counts of discrete Ensembl VEP predictions**

* Count VEP predictions in levels of a given phenotype
    + returned as a `data.frame` or a stacked `r Biocpkg("ggplot2")`
        `geom_bar` layer
    + returned as a `geom_bar` layer representing stacked
        *percentage* of VEP predictions
    + optionally faceted by another Ensembl VEP prediction
        (*e.g.* `"Feature"`)

**Density of continuous Ensembl VEP predictions**

* Ditribution of VEP predictions in levels of a phenotype
    + as a `r Biocpkg("ggplot2")` `geom_density` and/or `geom_dotplot` layer
    + as a `data.frame` listing all values faceted by phenotype level
    + optionally faceted by another Ensembl VEP prediction

# Installation {#Installation}

The VCF Tool Box can be installed using the following code:

```{r biocLite, eval=FALSE}
# Currently:
devtools::install_github("kevinrue/TVTB")
# Soon:
source("http://bioconductor.org/biocLite.R")
biocLite("TVTB")
```

Once installed, the package can be loaded and attached as follows:

```{r library}
library(TVTB)
```

# Recurrent settings: TVTBparam {#TVTBparam}

Many functionalities in `r Biocpkg("TVTB")` require recurrent information
such as:

* Genotype encoding (homozygote reference, heterozygote, homozygote alternate),
* INFO key that contains the Ensembl VEP predictions in the VCF file,
* Suffixes of INFO keys where counts and frequencies of genotypes must be
    stored:
    + Counts and frequencies may be calculated for individual levels of
        selected phenotypes, in which case the data will be stored
        under INFO keys formed as `<phenotype>_<level>_<suffix>`,
    + Counts and frequencies across all samples are stored in INFO keys
        simply named `<suffix>`.
* Settings for parallel calculations.

\bioccomment{
INFO key suffixes should be considered carefully to avoid conflicts
with INFO keys already present in the `VCF` object.
}

To reduce the burden of repetition during programming, and to 
facilitate analyses using consistent sets of parameters,
`r Biocpkg("TVTB")` implements the `TVTBparam` class.
The `TVTBparam` class offer a container for parameters recurrently used
across the package.
A `TVTBparam` object may be initialised as follows:

```{r TVTBparamCreate}
tparam <- TVTBparam(
    genos = list(
        REF = c("0|0"),
        HET = c("0|1", "1|0", "0|2", "2|0", "1|2", "2|1"),
        ALT = c("1|1", "2|2")), # required
    ranges = GenomicRanges::GRangesList( # optional
        GenomicRanges::GRanges(
            seqnames = "15",
            IRanges::IRanges(
                start = 48413170, end = 48434757, names = "SLC24A5")
            )
        ),
    aaf = "AAF", # default (optional)
    maf = "MAF", # default (optional)
    vep = "CSQ", # default (optional)
    bp = BiocParallel::SerialParam()) # default (optional)
```

`TVTBparam` objects have a convenient summary view:

```{r TVTBparamView}
tparam
```

In addition, accessors and setters were implemented for all slots of the class.

In this example:

* **Genotypes**
    + Accessor: `genos(tparam)`
    + Homozygote reference genotype is encoded `"0|0"`.
    + Counts of reference genotypes are stored in INFO keys suffixed with
        `"REF"`.
    + Heterozygote genotypes are encoded as
        `"0|1"`, `"1|0"`, `"0|2"`, `"2|0"`, `"1|2"`, and `"2|1"`.
    + Counts of heterozygote genotypes are stored in INFO keys suffixed with
        `"HET"`.
    + Homozygote alternate  genotype is encoded `"1|1"`.
    + Counts of alternate genotypes are stored in INFO keys suffixed with
        `"ALT"`.
* **Genomic ranges**
    + Accessor: `ranges(tparam)`
    + A gene-coding region on chromosome `"15"`.
* **Alternate allele frequency**
    + Accessor: `aaf(tparam)`
    + Calculated values will be stored under INFO keys suffixed with `"AAF"`.
* **Minor allele frequency**
    + Accessor: `maf(tparam)`
    + Calculated values will be stored under INFO keys suffixed with `"MAF"`.
* **Ensembl VEP predictions**
    + Accessor: `vep(tparam)`
    + Information will be imported from the INFO field `"CSQ"`.
* **Parallel calculations**
    + Accessor: `bp(tparam)`
    + Inactivated: *Serial calculations will be performed*.

Default values are provided for all slots except genotypes, as these may vary
more frequently from one data set to another (*e.g.* phased, unphased,
imputed).

# Data import {#Import}

## Genetic variants {#ImportVariants}

Functionalities in `r Biocpkg("TVTB")` support
`CollapsedVCF` and `ExpandedVCF` objects
(both extending the virtual class `VCF`) of the 
`r Biocpkg("VariantAnnotation")` package.

Typically, `CollapsedVCF` objects are produced by the
`r Biocpkg("VariantAnnotation")` `readVcf` method after parsing a VCF file,
and `ExpandedVCF` objects result of the
`r Biocpkg("VariantAnnotation")` `expand` method applied to
a `CollapsedVCF` object.

Any information that users deem relevant for the analysis may be
imported from VCF files and stored in
`VCF` objects passed to `r Biocpkg("TVTB")` methods.
However, to enable the key functionalities of the package,
the various slots of a `VCF` object should include
at least the following information:

* `fixed(x)`
    + No minimal requirement.
    + **Recommended**: at least the fields `"REF"` and `"ALT"`.
    
* `info(x)`
    + No minimal requirement.
    + **Recommended**:
        field `<vep>`: where `<vep>` stands for the INFO key where
        the Ensembl VEP predictions are stored in the `VCF` object.
    
* `geno(x)`
    + `GT`: genotypes.

* `colData(x)`: phenotypes.

\bioccomment{
In the future, `geno(x)[["GQ"]]` may be recommended, if available.
For instance, this could enable inclusion (or exclusion) of individual
genotypes on the basis of passing a genotype quality cut-off
when counting genotypes in phenotype levels.
}

## List of genomic ranges {#ImportGRangesList}

In the near future, `r Biocpkg("TVTB")` functionalities are expected to
produce summary statistics and plots faceted by meta-features,
each potentially composed of multiple genomic ranges.

For instance, burden tests may be performed on a set of transcripts,
considering only variants in their respective sets of exons.
The `r Biocpkg("GenomicRanges")` `GRangesList` class is an ideal container
in example,
as each `GRanges` in the `GRangesList` would represent a transcript,
and each element in the `GRanges` would represent an exon.

Although currently, none of the `r Biocpkg("TVTB")` package functions
access the `ranges` slot
of `TVTBparam` objects, users may already use it to store a list of genomic
ranges, thereby reducing the number of objects in their workspace.
For instance, the `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class
accepts `r Biocpkg("GenomicRanges")` `GRanges` objects (in the `which` slot)
that describes the sequences and ranges to be queried from VCF file(s):

```{r, reduceGRangesList, results='hide'}
ScanVcfParam(which = GenomicRanges::reduce(unlist(ranges(tparam))))
```

**Tip**: In the chunk of code above, the `reduce` method is used to ensure
that each genomic position is only covered by a single `GRanges`,
therefore reducing the chances of importing certain variants multiple times
(this occurs if they overlap multiple `GRanges`). Note that after reduction 
genetic insertions and deletions may still overlap
distinct non-overlapping `GRanges`,
or stranded `GRanges` overlapping from an unstranded perspective.

## Phenotypes {#ImportPhenotypes}

Although `VCF` objects may be constructed without attached phenotype data,
phenotype information is critical to interpret and compare genetic variants
between groups of samples
(*e.g.* burden of damaging variants in different phenotype levels).

`VCF` objects accept phenotype information
(as `r Biocpkg("S4Vectors")` `DataFrame`) in the `colData` slot.
This practice has the key advantage of keeping phenotype and genetic
information synchronised through operation such as subsetting and re-ordering,
limiting [software entropy](https://en.wikipedia.org/wiki/Software_entropy)
and confusion.

## Example {#ImportExample}

An `ExpandedVCF` object that contains the minimal data necessary for the rest
of the vignette can be created as follows:

**Step 1:** Import phenotypes

```{r importPhenotypes}
extdata <- system.file("extdata", package = "TVTB")
phenoFile <- file.path(extdata, "integrated_samples.txt")
phenotypes <- S4Vectors::DataFrame(
    read.table(file = phenoFile, header = TRUE, row.names = 1))
```

**Step 2:** Define the VCF file to parse

```{r vcfFile}
vcfFile <- file.path(extdata, "chr15.phase3_integrated.vcf.gz")
tabixVcf <- Rsamtools::TabixFile(file = vcfFile)
```

**Step 3:** Define VCF import parameters

```{r ScanVcfParam}
svp <- VariantAnnotation::ScanVcfParam(
    fixed = c("ALT", "QUAL", "FILTER"), # all fields: could be omitted
    info = vep(tparam), # an application of the TVTBparam class
    geno = "GT", # all fields: could be omitted in this case
    samples = rownames(phenotypes),
    which = GenomicRanges::reduce(unlist(ranges(tparam))))
```

Of particular interest in the above chunk of code, the slots:

* `samples`: import only samples with phenotype information
* `info` demonstrates the utility of the `TVTBparam` class for storing
    recurrent parameters
* `which`: import only variants in the targeted list of genomic ranges;
    demonstrates another application of the `TVTBparam` class

**Step 4:** Import and pre-process variants

```{r preprocessVariants, message=FALSE}
# Import variants as a CollapsedVCF object
vcf <- VariantAnnotation::readVcf(file = tabixVcf, param = svp)
# Combine with phenotype information
SummarizedExperiment::colData(vcf) <- phenotypes
# Expand into a ExpandedVCF object (bi-allelic records)
vcf <- VariantAnnotation::expand(x = vcf, row.names = TRUE)
```

The result is an `ExpandedVCF` object that includes variants
in the targeted genomic range(s) and samples:

```{r vcf, echo=FALSE}
vcf
```

# Adding allele frequencies {#Frequencies}

Although interesting figures and summary tables may be obtained
as soon as the first `ExpandedVCF` object is created
(see section [Summarising Ensembl VEP predictions](#Summarise)),
those methods may benefit from information added to additional INFO keys
after data import, either manually by the user, or through various
methods implemented in the `r Biocpkg("TVTB")` package.

## Adding overall frequencies {#FrequenciesOverall}

For instance, the method `addOverallFrequencies` uses the
reference homozoygote (*REF*), heterozygote (*HET*),
and homozygote alternate (*ALT*) genotypes defined in a `TVTBparam` object
to obtain the count of each genotype in an `ExpandedVCF` object.
Immediately thereafter, the method uses those counts to calculate
alternate allele frequency (*AAF*) and minor allele frequency (*MAF*).
Finally, the method stores the five calculated values
(*REF*, *HET*, *ALT*, *AAF*, and *MAF*)
in INFO keys defined by suffixes also declared in the `TVTBparam` object.

```{r addOverallFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addOverallFrequencies(vcf = vcf, param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addOverallFrequencies` method is synonym to the `addFrequencies`
method missing the argument `phenos`:

```{r addFrequenciesOverall}
vcf <- addFrequencies(vcf = vcf, param = tparam, force = TRUE)
```

\bioccomment{
The optional argument `force = TRUE` is used here
to overwrite INFO keys created in the previous chunk of code.
}

## Adding frequencies within phenotype level(s) {#FrequenciesPhenoLevel}

Similarly, the method `addPhenoLevelFrequencies` obtains the count of each
genotype in samples associated with given level(s) of given phenotype(s),
and stores the calculated values in INFO keys defined as 
`<pheno>_<level>_<suffix>`, with suffixes defined in the `TVTBparam` object.

```{r addPhenoLevelFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addPhenoLevelFrequencies(
    vcf = vcf, pheno = "super_pop", level = "AFR", param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addPhenoLevelFrequencies` method is synonym
to the `addFrequencies`
method called with the argument `phenos` given as a list where `names` are
phenotypes, and values are `character` vectors of levels to
process within each phenotype:

```{r addFrequenciesPhenoLevel}
initialInfo <- colnames(info(vcf))
vcf <- addFrequencies(
    vcf = vcf, phenos = list(
        super_pop = c("EUR", "AFR"),
        pop = c("GBR", "FIN", "MSL")),
    param = tparam, force = TRUE)
setdiff(colnames(info(vcf)), initialInfo)
```

# Filtering variants {#Filter}

Although `VCF` objects are straightforward to subset
using either indices and row names
(as they inherit from the `r Biocpkg("SummarizedExperiment")` 
`RangedSummarizedExperiment` class),
users may wish to identify variants that pass combinations of criteria based on
information in their `fixed` slot, `info` slot, and Ensembl VEP predictions,
a non-trivial task due to those pieces of information being stored in
different slots of the `VCF` object, and the *1:N* relationship
between variants and EnsemblVEP predictions.

## Definition of VCF filter rules {#FilterDefine}

To facilitate the definition of VCF filter rules, and their application to
`ExpandedVCF` objects, `r Biocpkg("TVTB")` extends the `r Biocpkg("S4Vectors")`
`FilterRules` class in four new classes of filter rules:

|       Class       | Motivation                                              |
| :--------------:  | :------------------------------------------------------ |
|  VcfFixedRules    | Filter rules applicable to the `fixed` slot of a        |
|                   | `VCF` object.                                           |
|                   |                                                         |
|   VcfInfoRules    | Filter rules applicable to the `info` slot of a         |
|                   | `VCF` object.                                           |
|                   |                                                         |
|   VcfVepRules     | Filter rules applicable to the Ensembl VEP predictions  |
|                   | stored in a given INFO key of a `VCF` object.           |
|                   |                                                         |
|  VcfFilterRules   | Combination of `VcfFixedRules`, `VcfInfoRules`, and     |
|                   |  `VcfVepRules` applicable to a `VCF` object.            |

Table: Motivation for each of the new classes extending `FilterRules`
to define VCF filter rules.

Instances of those classes may be initialised as follows:

**VcfFixedRules**

```{r VcfFixedRules}
fixedR <- VcfFixedRules(exprs = list(
    pass = expression(FILTER == "PASS"),
    qual = expression(QUAL > 20)
    ))
fixedR
```

**VcfInfoRules**

```{r VcfInfoRules}
infoR <- VcfInfoRules(exprs = list(
    common = expression(MAF > 0.1), # minor allele frequency
    present = expression(ALT + HET > 0) # count of non-REF homozygotes
    ),
    active = c(TRUE, FALSE))
infoR
```

`FilterRules` are initialised in an active state by default.
The above chunk of code demonstrate how the `active` argument
of their constructor may be used to initialise
specific filter rules in an inactive state.

**VcfVepRules**

```{r VcfVepRules}
vepR <- VcfVepRules(exprs = list(
    missense = expression(Consequence %in% c("missense_variant")),
    CADD = expression(CADD_PHRED > 15)
    ))
vepR
```

**VcfFilterRules**

`VcfFilterRules` combine VCF filter rules of  different types
in a single object.

```{r VcfFilterRules}
vcfRules <- VcfFilterRules(fixedR, infoR, vepR)
vcfRules
```

This vignette offers only a brief peek into the utility and flexibility of
VCF filter rules. More (complex) examples are given in a separate
vignette, including filter rules using functions and pattern matching.
The documentation of the `r Biocpkg("S4Vectors")` package---where the parent
class `FilterRules` is defined---can also be a source of inspiration.

## Control of VCF filter rules {#FilterControl}

As the above classes of *VCF filter rules* inherit
from the `r Biocpkg("S4Vectors")` `FilterRules` class,
they also benefit from its accessors and methods.
For instance, VCF filter rules can easily be toggled
between active and inactive states:

```{r deactivateCADD}
active(vcfRules)["CADD"] <- FALSE
active(vcfRules)
```

A separate vignette described in greater detail the use of classes
that contain *VCF filter rules*.

Manipulation of *VCF filter rules* is described in more depth in a separate
vignette.

## Evaluation of VCF filter rules {#FilterEval}

Once defined, the above filter rules can be applied to `ExpandedVCF` objects,
in the same way as `FilterRules` are evaluated in a given environment
(see the `r Biocpkg("S4Vectors")` documentation):

```{r}
summary(eval(expr = infoR, envir = vcf))
summary(eval(expr = vcfRules, envir = vcf))
summary(evalSeparately(expr = vcfRules, envir = vcf))
```

\bioccomment{
Note how the inactive rule `CADD` returns `TRUE` for all variants.
}

\fixme{
I am not clear why in the vignette `summary` behaves like `summary.data.frame`,
while RStudio seems to use a different method for `FilterMatrix`,
indicating the count of variant initially, after each individual filter,
and after evaluating all active filters.
}

# Summarising Ensembl VEP predictions {#Summarise}

As soon as genetic and phenotypic information are imported
into an `ExpandedVCF` object,
or after the object was extended with additional information,
the scientific value of the data may be revealed by
a variety of summary statistics and graphical representations.
This section presents severeal ideas implemented in `r Biocpkg("TVTB")`[^1].

[^1]: More ideas are underway.

It is important to highlight that `ggplot` objects
include the data used for plotting in their `data` slot.
Those data may be extracted, subsetted, and replaced to refine plots and
summary tables beyond those produced by the package methods.
In particular, the companion Shiny web-application *tSVE*
included in the package takes advantage of this
point to avoid calling multiple times certain time-consuming methods.

## Counts of discrete Ensembl VEP predictions {#SummariseDiscrete}

### Barplot {#SummariseDiscreteBarplot}

The following chunk of code displays,
for each super-population
(*i.e.*, each level of the `"super_pop"` phenotype),
the count of each Ensembl VEP prediction `"Consequence"`
affecting each "genomic feature" (*i.e.*, transcript),
considering for each super-population only variants:

* Seen at least once among the corresponding group of samples,
* With a [CADD score](http://cadd.gs.washington.edu)[^2] greater than `20`.

[^2]: A tool for scoring the deleteriousness of genetic variants.

```{r optsTabulateSet, include=FALSE}
opts_chunk$set(
    fig.width=13,
    fig.height=7,
    out.extra='angle=90',
    out.width='7in',
    out.height='13in'
)
```

```{r tCBPplot, fig.cap="Counts of Ensembl VEP predictions."}
library(ggplot2)
filterCADD <- VcfVepRules(exprs = list(
    CADD_20 = expression(as.numeric(CADD_PHRED) > 20)
    ))
tCBPplot <- tabulateVepByPhenotype(
    vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
    param = tparam, filter = filterCADD,
    unique = TRUE, facet = "Feature", percentage = FALSE,
    plot = TRUE) +
    theme(
        legend.text = element_text(size = rel(0.8)),
        axis.text.x = element_text(angle = 270,vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270,hjust = 0.5)
    )

tCBPplot
```

```{r optsTabulateReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

### Table (data.frame) {#SummariseDiscreteTable}

The same counts can also be summarised as a `data.frame` using
the option `plot=FALSE`:

```{r tCBPtableWide}
tCBPwide <- tabulateVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
        param = tparam,
        unique = TRUE, facet = "Feature", plot = FALSE
    )
```

of which only the subset corresponding to *missense variants* is shown here:

```{r tCBPtableWideSubset, eval=FALSE}
subset(tCBPwide, Consequence == "missense_variant")
```

```{r tCBPtableWideSubsetShow, results="asis", echo=FALSE}
knitr::kable(
    x = subset(tCBPwide, Consequence == "missense_variant"),
    row.names = FALSE,
    caption = "Table of consequence by phenotype by feature in wide format.")
```

## Distribution of continuous Ensembl VEP predictions {#SummariseContinuous}

For Ensembl VEP predictions on a continuous scale, it may be interesting to
visualise the distribution of values as a density plot.
In the following chunk of code, the density distribution of
[CADD score](http://cadd.gs.washington.edu) is visualised
for *missense variants* affecting each feature in each super-population:

```{r optsDensitySet, include=FALSE}
opts_chunk$set(
    fig.width=13,
    fig.height=7,
    out.extra='angle=90',
    out.width='7in',
    out.height='13in'
)
```

```{r dCBPplot, fig.cap="Density and dot plots of Ensembl VEP predictions."}
densityVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "CADD_PHRED",
        param = tparam, filter = vcfRules["missense"],
        unique = TRUE, facet = "Feature", plot = TRUE, popFreq = FALSE,
        layer = "density+dotplot") +
    theme(
        legend.key.size = unit(1.2, "lines"),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)),
        axis.text.x = element_text(angle = 270,
            vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270, hjust = 0.5)
    )
```

\bioccomment{
The vertical density lines and rectangles are visual artefacts produced when
only one or two variants are seen in a given phenotype level, respectively.
}

```{r optsDensityReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

# Acknowledgement

Dr. Stefan Gräf and Mr. Matthias Haimel
for advice on the VCF file format and the Ensembl VEP script.
Prof. Martin Wilkins for his trust and support.

Last but not least, the amazing collaborative effort of the `rep("many",10)`
[Bioconductor](http://bioconductor.org) developers whose hard work
appears through the dependencies of this package.

# Session info {#SessionInfo}

Here is the output of `sessionInfo()` on the system on which this document was
compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {#References}

[R]: http://r-project.org
[RStudio]: http://www.rstudio.com/
